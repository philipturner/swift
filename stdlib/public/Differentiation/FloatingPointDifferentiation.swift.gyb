//===--- FloatingPointDifferentiation.swift.gyb ---------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import Swift
import SwiftShims

% from SwiftFloatingPointTypes import all_floating_point_types
% for self_type in all_floating_point_types():
%{
Self = self_type.stdlib_name
bits = self_type.bits

def Availability(bits):
    if bits == 16:
        return '@available(SwiftStdlib 5.3, *)'
    return ''
}%

% if bits == 80:
#if !(os(Windows) || os(Android)) && (arch(i386) || arch(x86_64))
% end
% if bits == 16:
#if !((os(macOS) || targetEnvironment(macCatalyst)) && arch(x86_64))
% end

//===----------------------------------------------------------------------===//
// Protocol conformances
//===----------------------------------------------------------------------===//

${Availability(bits)}
extension ${Self}: Differentiable {
  public typealias TangentVector = ${Self}
}

//===----------------------------------------------------------------------===//
// Derivatives
//===----------------------------------------------------------------------===//

/// Derivatives of standard unary operators.
${Availability(bits)}
extension ${Self} {
%for derivative_kind in ['vjp', 'jvp']:
%  linear_map_kind = 'differential' if derivative_kind == 'jvp' else 'pullback'
  // TODO: Add derivative of `init<Source>()` where Source: FloatingPoint
  // TODO: Add derivative of `init(signOf:magnitudeOf:)`
  // TODO: Add derivative of `sign`
  // TODO: Add derivative of `magnitude`
  // TODO: Add derivative of `round()`
  // TODO: Add derivative of `rounded()`

  @inlinable
  @derivative(of: -)
  static func _${derivative_kind}Negate(
    _ x: ${Self}
  ) -> (value: ${Self}, ${linear_map_kind}: (${Self}) -> ${Self}) {
    return (-x, { v in -v })
  }

  @inlinable
  @derivative(of: negate)
  mutating func _${derivative_kind}NegateAssign() -> (
    value: Void, ${linear_map_kind}: (inout Self) -> Void
  ) {
    negate()
    return ((), { dx in dx.negate() })
  }

  @inlinable
  @derivative(of: formSquareRoot)
  mutating func _${derivative_kind}FormSquareRoot() -> (
    value: Void, ${linear_map_kind}: (inout Self) -> Void
  ) {
    formSquareRoot()
    let value = self
    return ((), { v in v /= 2 * value })
  }
%end # for derivative_kind in ['jvp', 'vjp']:
}

/// Derivatives of standard binary operators.
${Availability(bits)}
extension ${Self} {
  // TODO: Add derivative of `formRemainder(dividingBy:)`
  // TODO: Add derivative of `formTruncatingRemainder(dividingBy:)`
  // TODO: Add derivative of `remainder(dividingBy:)`
  // TODO: Add derivative of `truncatingRemainder(dividingBy:)`

  @inlinable
  @derivative(of: +)
  static func _vjpAdd(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, pullback: (${Self}) -> (${Self}, ${Self})) {
    return (lhs + rhs, { v in (v, v) })
  }

  @inlinable
  @derivative(of: +)
  static func _jvpAdd(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, differential: (${Self}, ${Self}) -> ${Self}) {
    return (lhs + rhs, { (dlhs, drhs) in dlhs + drhs })
  }

  @inlinable
  @derivative(of: +=)
  static func _vjpAddAssign(
    _ lhs: inout ${Self}, 
    _ rhs: ${Self}
  ) -> (value: Void, pullback: (inout ${Self}) -> ${Self}) {
    lhs += rhs
    return ((), { v in v })
  }

  @inlinable
  @derivative(of: +=)
  static func _jvpAddAssign(
    _ lhs: inout ${Self}, 
    _ rhs: ${Self}
  ) -> (value: Void, differential: (inout ${Self}, ${Self}) -> Void) {
    lhs += rhs
    return ((), { $0 += $1 })
  }

  @inlinable
  @derivative(of: -)
  static func _vjpSubtract(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, pullback: (${Self}) -> (${Self}, ${Self})) {
    return (lhs - rhs, { v in (v, -v) })
  }

  @inlinable
  @derivative(of: -)
  static func _jvpSubtract(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, differential: (${Self}, ${Self}) -> ${Self}) {
    return (lhs - rhs, { (dlhs, drhs) in dlhs - drhs })
  }

  @inlinable
  @derivative(of: -=)
  static func _vjpSubtractAssign(
    _ lhs: inout ${Self}, 
    _ rhs: ${Self}
  ) -> (value: Void, pullback: (inout ${Self}) -> ${Self}) {
    lhs -= rhs
    return ((), { v in -v })
  }

  @inlinable
  @derivative(of: -=)
  static func _jvpSubtractAssign(
    _ lhs: inout ${Self}, 
    _ rhs: ${Self}
  ) -> (value: Void, differential: (inout ${Self}, ${Self}) -> Void) {
    lhs -= rhs
    return ((), { $0 -= $1 })
  }

  @inlinable
  @derivative(of: *)
  static func _vjpMultiply(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, pullback: (${Self}) -> (${Self}, ${Self})) {
    return (lhs * rhs, { v in (rhs * v, lhs * v) })
  }

  @inlinable
  @derivative(of: *)
  static func _jvpMultiply(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, differential: (${Self}, ${Self}) -> ${Self}) {
    return (lhs * rhs, { (dlhs, drhs) in lhs * drhs + rhs * dlhs })
  }

  @inlinable
  @derivative(of: *=)
  static func _vjpMultiplyAssign(
    _ lhs: inout ${Self},
    _ rhs: ${Self}
  ) -> (value: Void, pullback: (inout ${Self}) -> ${Self}) {
    let oldLhs = lhs
    lhs *= rhs
    return ((), { v in
      let drhs = oldLhs * v
      v *= rhs
      return drhs
    })
  }

  @inlinable
  @derivative(of: *=)
  static func _jvpMultiplyAssign(
    _ lhs: inout ${Self}, 
    _ rhs: ${Self}
  ) -> (value: Void, differential: (inout ${Self}, ${Self}) -> Void) {
    let oldLhs = lhs
    lhs *= rhs
    return ((), { $0 = $0 * rhs + oldLhs * $1 })
  }

  @inlinable
  @derivative(of: /)
  static func _vjpDivide(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, pullback: (${Self}) -> (${Self}, ${Self})) {
    return (lhs / rhs, { v in (v / rhs, -lhs / (rhs * rhs) * v) })
  }

  @inlinable
  @derivative(of: /)
  static func _jvpDivide(
    _ lhs: ${Self}, 
    _ rhs: ${Self}
  ) -> (value: ${Self}, differential: (${Self}, ${Self}) -> ${Self}) {
    return (lhs / rhs, { (dlhs, drhs) in dlhs / rhs - lhs / (rhs * rhs) * drhs })
  }

  @inlinable
  @derivative(of: /=)
  static func _vjpDivideAssign(
    _ lhs: inout ${Self}, 
    _ rhs: ${Self}
  ) -> (value: Void, pullback: (inout ${Self}) -> ${Self}) {
    let oldLhs = lhs
    lhs /= rhs
    return ((), { v in
      let drhs = -oldLhs / (rhs * rhs) * v
      v /= rhs
      return drhs
    })
  }

  @inlinable
  @derivative(of: /=)
  static func _jvpDivideAssign(
    _ lhs: inout ${Self}, 
    _ rhs: ${Self}
  ) -> (value: Void, differential: (inout ${Self}, ${Self}) -> Void) {
    let oldLhs = lhs
    lhs /= rhs
    return ((), { $0 = ($0 * rhs - oldLhs * $1) / (rhs * rhs)  })
  }
}

/// Derivatives of tertiary operators
${Availability(bits)}
extension ${Self} {
  // TODO(SR-15793) enable derivative of `addProduct` once bug is fixed
  /*
  @inlinable
  @derivative(of: addProduct)
  mutating func _vjpAddProduct(
    _ lhs: Self, 
    _ rhs: Self
  ) -> (value: Void, pullback: (inout Self) -> (Self, Self)) {
    addProduct(lhs, rhs)
    return ((), { v in (v * rhs, v * lhs) })
  }

  @inlinable
  @derivative(of: addProduct) 
  mutating func _jvpAddProduct(
    _ lhs: Self, 
    _ rhs: Self
  ) -> (value: Void, differential: (inout Self, Self, Self) -> Void) {
    addProduct(lhs, rhs)
    return ((), { (dSelf, dlhs, drhs) in 
      dSelf = dSelf + dlhs * rhs + drhs * lhs
    })
  }
  */
}

% if bits == 80 or bits == 16:
#endif
% end
% end

extension FloatingPoint
where
  Self: Differentiable,
  Self == Self.TangentVector
{
  @inlinable
  @derivative(of: addingProduct)
  func _vjpAddingProduct(
    _ lhs: Self, 
    _ rhs: Self
  ) -> (value: Self, pullback: (Self) -> (Self, Self, Self)) {
    return (addingProduct(lhs, rhs), { v in (v, v * rhs, v * lhs) })
  }

  @inlinable
  @derivative(of: addingProduct)
  func _jvpAddingProduct(
    _ lhs: Self, 
    _ rhs: Self
  ) -> (value: Self, differential: (Self, Self, Self) -> Self) {
    return (addingProduct(lhs, rhs), { (dSelf, dlhs, drhs) in 
      dSelf + dlhs * rhs + drhs * lhs
    })
  }

%for derivative_kind in ['vjp', 'jvp']:
%  linear_map_kind = 'differential' if derivative_kind == 'jvp' else 'pullback'
  @inlinable
  @derivative(of: squareRoot)
  func _${derivative_kind}SquareRoot() -> (value: Self, ${linear_map_kind}: (Self) -> Self) {
    let value = squareRoot()
    return (value, { v in v / (2 * value) })
  }
%end # for derivative_kind in ['jvp', 'vjp']:

%for compare_op in ['minimum', 'maximum']:
%  compare_symbol = '<=' if compare_op == 'minimum' else '>'
%  compare_camel = 'Minimum' if compare_op == 'minimum' else 'Maximum' # to ensure camel case
%  for suffix in ['', 'Magnitude']:
%    magnitude_op = 'abs' if suffix == 'Magnitude' else ''
  @inlinable
  @derivative(of: ${compare_op}${suffix})
  static func _vjp${compare_camel}${suffix}(
    _ x: Self,
    _ y: Self
  ) -> ( // TODO: try using `Self` instead of `TangentVector` here
    value: Self, pullback: (Self) -> (Self, Self)
  ) {
    if ${magnitude_op}(x) ${compare_symbol} ${magnitude_op}(y) || y.isNaN { 
      return (x, { v in (v, .zero) }) 
    } else {
      return (y, { v in (.zero, v) })
    }
  }

  @inlinable
  @derivative(of: ${compare_op}${suffix})
  static func _jvp${compare_camel}${suffix}(
    _ x: Self, 
    _ y: Self
  ) -> (
    value: Self, differential: (Self, Self) -> (Self)
  ) {
    if ${magnitude_op}(x) ${compare_symbol} ${magnitude_op}(y) || y.isNaN { 
      return (x, { (dx, _) in dx }) 
    } else {
      return (y, { (_, dy) in dy })
    }
  }
%  end # for suffix in ['', 'Magnitude']:
%end # for compare_op in ['minimum', 'maximum']:
}
